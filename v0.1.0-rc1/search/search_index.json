{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UtilityFog Fractal TreeOpen v0.1.0-rc1 \u00b6 Welcome to the UtilityFog Fractal TreeOpen documentation for release candidate v0.1.0-rc1. Phase 3 Features \u00b6 This release includes comprehensive Phase 3 capabilities: Telemetry System : Complete metrics collection and export CLI Visualization : Interactive ASCII visualization with multiple formats Observability : Structured JSON logging with distributed tracing Feature Flags : Centralized configuration management Quick Start \u00b6 # Install from release pip install utilityfog-fractal-treeopen == 0 .1.0rc1 # Run basic commands ufog --help ufog visualize --demo --out html ufog-telemetry ufog-observe Release Information \u00b6 Version : v0.1.0-rc1 Release Date : September 22, 2025 Tag : v0.1.0-rc1 Commit : 955eb98d0acc94d0ee4a9acf677b0284fa197cb9 Links \u00b6 GitHub Repository Release v0.1.0-rc1","title":"Home"},{"location":"#utilityfog-fractal-treeopen-v010-rc1","text":"Welcome to the UtilityFog Fractal TreeOpen documentation for release candidate v0.1.0-rc1.","title":"UtilityFog Fractal TreeOpen v0.1.0-rc1"},{"location":"#phase-3-features","text":"This release includes comprehensive Phase 3 capabilities: Telemetry System : Complete metrics collection and export CLI Visualization : Interactive ASCII visualization with multiple formats Observability : Structured JSON logging with distributed tracing Feature Flags : Centralized configuration management","title":"Phase 3 Features"},{"location":"#quick-start","text":"# Install from release pip install utilityfog-fractal-treeopen == 0 .1.0rc1 # Run basic commands ufog --help ufog visualize --demo --out html ufog-telemetry ufog-observe","title":"Quick Start"},{"location":"#release-information","text":"Version : v0.1.0-rc1 Release Date : September 22, 2025 Tag : v0.1.0-rc1 Commit : 955eb98d0acc94d0ee4a9acf677b0284fa197cb9","title":"Release Information"},{"location":"#links","text":"GitHub Repository Release v0.1.0-rc1","title":"Links"},{"location":"OBSERVABILITY/","text":"FT-010: Observability System Documentation \u00b6 Overview \u00b6 The FT-010 Observability System provides comprehensive structured logging, distributed tracing, and telemetry integration for the UtilityFog-Fractal-TreeOpen simulation system. This system enables deep visibility into simulation operations, performance monitoring, and debugging capabilities. Features \u00b6 \ud83d\udd0d Structured Logging \u00b6 JSON-formatted logs with consistent schema Contextual metadata automatically attached to log entries Multiple log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL) Thread-safe logging for concurrent operations \ud83d\udd17 Distributed Tracing \u00b6 Trace ID propagation across operations and threads Operation lifecycle tracking (start, complete, error) Performance metrics collection per operation Context managers and decorators for easy integration \ud83d\udcca Rate-Limited Error Logging \u00b6 Intelligent error suppression to prevent log spam Configurable rate limits per error type Automatic rate limit reset after time windows Summary logging when rate limits are exceeded \ud83d\udcc8 Event Logging System \u00b6 Structured event tracking for simulation events Event counting and aggregation Flexible event data with arbitrary metadata Integration with telemetry system \ud83d\udd27 Telemetry Integration \u00b6 Enhanced TelemetryCollector with observability hooks Performance metric collection with tracing Simulation metrics with structured logging Export capabilities for external monitoring systems Architecture \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ObservabilityManager \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 StructuredLogger\u2502 \u2502 TraceContext \u2502 \u2502 EventLogger \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502RateLimitedLogger\u2502 \u2502TracingDecorator \u2502 \u2502 Metrics \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 TelemetryCollector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2022 Performance Metrics \u2022 Simulation Metrics \u2502 \u2502 \u2022 Historical Data \u2022 Export Capabilities \u2502 \u2502 \u2022 Thread-Safe Operations \u2022 Observability Integration \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Usage Guide \u00b6 Basic Setup \u00b6 from agent.observability import initialize_observability , get_observability_manager # Initialize the observability system obs_manager = initialize_observability ( log_level = logging . INFO ) # Or get the global instance obs_manager = get_observability_manager () Structured Logging \u00b6 from agent.observability import get_observability_manager obs = get_observability_manager () # Basic logging with metadata obs . logger . info ( \"Simulation started\" , agents_count = 100 , environment = \"test\" ) # Error logging with context obs . logger . error ( \"Agent collision detected\" , agent_id = 123 , position = [ 10 , 20 , 30 ], severity = \"high\" ) Distributed Tracing \u00b6 Using Context Manager \u00b6 from agent.observability import trace_operation # Trace an operation with trace_operation ( \"agent_movement_calculation\" , agent_id = 123 ) as trace_id : # Your operation code here calculate_agent_movement () # Nested operations inherit the trace ID with trace_operation ( \"collision_detection\" ): detect_collisions () Using Decorator \u00b6 from agent.observability import trace_function @trace_function ( \"complex_simulation_step\" ) def run_simulation_step ( agents , environment ): # Function automatically traced # Start and completion logged # Errors automatically captured return process_simulation ( agents , environment ) Event Logging \u00b6 from agent.observability import log_simulation_event # Log simulation events log_simulation_event ( \"agent_created\" , agent_id = 456 , agent_type = \"explorer\" , initial_position = [ 0 , 0 , 0 ]) log_simulation_event ( \"environment_changed\" , change_type = \"temperature\" , old_value = 20.5 , new_value = 25.3 , affected_area = \"sector_7\" ) Rate-Limited Error Logging \u00b6 from agent.observability import log_rate_limited_error # Errors are automatically rate-limited by error key for agent in problematic_agents : log_rate_limited_error ( error_key = \"agent_pathfinding_error\" , message = f \"Agent { agent . id } pathfinding failed\" , agent_id = agent . id , error_count = agent . error_count ) Telemetry Integration \u00b6 from agent.telemetry_collector import get_telemetry_collector collector = get_telemetry_collector () # Collect performance metrics (automatically traced) collector . collect_performance_metric ( \"agent_update\" , duration = 0.05 , success = True ) # Collect simulation metrics collector . collect_simulation_metrics ({ \"active_agents\" : 150 , \"average_speed\" : 2.3 , \"collision_rate\" : 0.02 }) # Get comprehensive metrics including observability data metrics = collector . get_current_metrics () print ( f \"Observability metrics: { metrics [ 'observability' ] } \" ) Configuration \u00b6 Log Levels \u00b6 import logging from agent.observability import initialize_observability # Configure different log levels obs_manager = initialize_observability ( log_level = logging . DEBUG ) # Verbose obs_manager = initialize_observability ( log_level = logging . INFO ) # Standard obs_manager = initialize_observability ( log_level = logging . WARNING ) # Minimal Rate Limiting \u00b6 from agent.observability import ObservabilityManager , RateLimitedErrorLogger obs_manager = ObservabilityManager () # Configure custom rate limits rate_limiter = RateLimitedErrorLogger ( obs_manager . logger , max_errors_per_minute = 5 # Allow 5 errors per minute per error key ) Telemetry History \u00b6 from agent.telemetry_collector import initialize_telemetry # Configure telemetry history size collector = initialize_telemetry ( max_history_size = 5000 ) Log Format \u00b6 All logs are output in structured JSON format: { \"timestamp\" : \"2025-09-21T16:30:45.123456Z\" , \"level\" : \"INFO\" , \"logger\" : \"ufog.observability\" , \"message\" : \"Starting traced operation: agent_movement\" , \"module\" : \"main_simulation\" , \"function\" : \"run_simulation_step\" , \"line\" : 42 , \"trace_id\" : \"trace_a1b2c3d4e5f6g7h8\" , \"operation\" : \"agent_movement\" , \"operation_phase\" : \"start\" , \"agent_id\" : 123 , \"position\" : [ 10.5 , 20.3 , 15.7 ] } Metrics and Monitoring \u00b6 Observability Metrics \u00b6 from agent.observability import get_metrics_summary metrics = get_metrics_summary () print ( f \"Operations completed: { metrics [ 'operations' ][ 'operations_completed' ] } \" ) print ( f \"Average duration: { metrics [ 'average_operation_duration' ] : .3f } s\" ) print ( f \"Current trace ID: { metrics [ 'current_trace_id' ] } \" ) Performance Monitoring \u00b6 from agent.telemetry_collector import get_telemetry_collector collector = get_telemetry_collector () performance = collector . get_performance_summary () for operation , stats in performance [ 'performance_metrics' ] . items (): print ( f \" { operation } : { stats [ 'success_rate' ] : .2% } success rate\" ) print ( f \" Average duration: { stats [ 'current_duration' ] : .3f } s\" ) Integration with Existing Code \u00b6 Minimal Integration \u00b6 # Add to existing functions from agent.observability import trace_function @trace_function () # Uses function name as operation name def existing_function (): # Existing code unchanged pass Comprehensive Integration \u00b6 from agent.observability import ( trace_operation , log_simulation_event , log_rate_limited_error , get_observability_manager ) def enhanced_simulation_step (): with trace_operation ( \"simulation_step\" ) as trace_id : log_simulation_event ( \"step_started\" , step_id = current_step ) try : # Existing simulation logic result = run_step_logic () log_simulation_event ( \"step_completed\" , step_id = current_step , agents_processed = len ( result . agents )) return result except Exception as e : log_rate_limited_error ( \"simulation_step_error\" , f \"Step { current_step } failed: { e } \" ) raise Best Practices \u00b6 1. Use Appropriate Log Levels \u00b6 DEBUG : Detailed diagnostic information INFO : General operational messages WARNING : Potentially problematic situations ERROR : Error conditions that don't stop execution CRITICAL : Serious errors that may stop execution 2. Include Relevant Context \u00b6 # Good: Rich context obs . logger . info ( \"Agent state changed\" , agent_id = agent . id , old_state = agent . previous_state , new_state = agent . current_state , trigger = \"collision_detected\" ) # Avoid: Minimal context obs . logger . info ( \"State changed\" ) 3. Use Trace Operations for Performance-Critical Code \u00b6 # Trace expensive operations with trace_operation ( \"pathfinding_calculation\" , agent_count = len ( agents )): paths = calculate_all_paths ( agents , environment ) 4. Leverage Rate-Limited Logging for Frequent Errors \u00b6 # For errors that might occur frequently for agent in agents : if agent . has_error (): log_rate_limited_error ( error_key = f \"agent_error_ { agent . error_type } \" , message = f \"Agent { agent . id } error: { agent . error_message } \" ) 5. Use Event Logging for State Changes \u00b6 # Track important state changes log_simulation_event ( \"phase_transition\" , from_phase = \"initialization\" , to_phase = \"simulation\" , duration = init_duration ) Troubleshooting \u00b6 Common Issues \u00b6 1. Missing Trace IDs \u00b6 Problem : Logs don't contain trace IDs Solution : Ensure operations are wrapped with trace_operation or @trace_function 2. Performance Impact \u00b6 Problem : Logging affects simulation performance Solution : Use appropriate log levels and consider async logging for high-frequency operations 3. Log Volume \u00b6 Problem : Too many logs generated Solution : Use rate-limited logging and adjust log levels Debugging \u00b6 # Enable debug logging import logging from agent.observability import initialize_observability obs = initialize_observability ( log_level = logging . DEBUG ) # Check current configuration metrics = obs . get_metrics_summary () print ( f \"Current configuration: { metrics } \" ) Performance Considerations \u00b6 Structured logging has minimal overhead (~1-2% in typical scenarios) Trace ID propagation uses thread-local storage for efficiency Rate limiting prevents log spam without losing important information JSON formatting is optimized for both human readability and machine parsing Future Enhancements \u00b6 Distributed tracing across multiple processes/services Metrics export to external monitoring systems (Prometheus, etc.) Log aggregation and analysis tools integration Real-time dashboards for simulation monitoring Alerting based on error rates and performance thresholds API Reference \u00b6 Core Classes \u00b6 ObservabilityManager : Main orchestrator for all observability features StructuredLogger : JSON-formatted logging with trace propagation TraceContext : Thread-local trace ID management RateLimitedErrorLogger : Intelligent error rate limiting EventLogger : Structured event tracking TracingDecorator : Function tracing decorator TelemetryCollector : Enhanced telemetry with observability integration Global Functions \u00b6 get_observability_manager() : Get global observability manager initialize_observability(log_level) : Initialize observability system trace_operation(name, **context) : Context manager for tracing log_simulation_event(event_type, **data) : Log simulation events log_rate_limited_error(key, message, **kwargs) : Rate-limited error logging trace_function(operation_name) : Function tracing decorator get_metrics_summary() : Get comprehensive metrics summary For detailed API documentation, see the inline docstrings in the source code.","title":"FT-010: Observability System Documentation"},{"location":"OBSERVABILITY/#ft-010-observability-system-documentation","text":"","title":"FT-010: Observability System Documentation"},{"location":"OBSERVABILITY/#overview","text":"The FT-010 Observability System provides comprehensive structured logging, distributed tracing, and telemetry integration for the UtilityFog-Fractal-TreeOpen simulation system. This system enables deep visibility into simulation operations, performance monitoring, and debugging capabilities.","title":"Overview"},{"location":"OBSERVABILITY/#features","text":"","title":"Features"},{"location":"OBSERVABILITY/#structured-logging","text":"JSON-formatted logs with consistent schema Contextual metadata automatically attached to log entries Multiple log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL) Thread-safe logging for concurrent operations","title":"\ud83d\udd0d Structured Logging"},{"location":"OBSERVABILITY/#distributed-tracing","text":"Trace ID propagation across operations and threads Operation lifecycle tracking (start, complete, error) Performance metrics collection per operation Context managers and decorators for easy integration","title":"\ud83d\udd17 Distributed Tracing"},{"location":"OBSERVABILITY/#rate-limited-error-logging","text":"Intelligent error suppression to prevent log spam Configurable rate limits per error type Automatic rate limit reset after time windows Summary logging when rate limits are exceeded","title":"\ud83d\udcca Rate-Limited Error Logging"},{"location":"OBSERVABILITY/#event-logging-system","text":"Structured event tracking for simulation events Event counting and aggregation Flexible event data with arbitrary metadata Integration with telemetry system","title":"\ud83d\udcc8 Event Logging System"},{"location":"OBSERVABILITY/#telemetry-integration","text":"Enhanced TelemetryCollector with observability hooks Performance metric collection with tracing Simulation metrics with structured logging Export capabilities for external monitoring systems","title":"\ud83d\udd27 Telemetry Integration"},{"location":"OBSERVABILITY/#architecture","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ObservabilityManager \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 StructuredLogger\u2502 \u2502 TraceContext \u2502 \u2502 EventLogger \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502RateLimitedLogger\u2502 \u2502TracingDecorator \u2502 \u2502 Metrics \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 TelemetryCollector \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2022 Performance Metrics \u2022 Simulation Metrics \u2502 \u2502 \u2022 Historical Data \u2022 Export Capabilities \u2502 \u2502 \u2022 Thread-Safe Operations \u2022 Observability Integration \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Architecture"},{"location":"OBSERVABILITY/#usage-guide","text":"","title":"Usage Guide"},{"location":"OBSERVABILITY/#basic-setup","text":"from agent.observability import initialize_observability , get_observability_manager # Initialize the observability system obs_manager = initialize_observability ( log_level = logging . INFO ) # Or get the global instance obs_manager = get_observability_manager ()","title":"Basic Setup"},{"location":"OBSERVABILITY/#structured-logging_1","text":"from agent.observability import get_observability_manager obs = get_observability_manager () # Basic logging with metadata obs . logger . info ( \"Simulation started\" , agents_count = 100 , environment = \"test\" ) # Error logging with context obs . logger . error ( \"Agent collision detected\" , agent_id = 123 , position = [ 10 , 20 , 30 ], severity = \"high\" )","title":"Structured Logging"},{"location":"OBSERVABILITY/#distributed-tracing_1","text":"","title":"Distributed Tracing"},{"location":"OBSERVABILITY/#using-context-manager","text":"from agent.observability import trace_operation # Trace an operation with trace_operation ( \"agent_movement_calculation\" , agent_id = 123 ) as trace_id : # Your operation code here calculate_agent_movement () # Nested operations inherit the trace ID with trace_operation ( \"collision_detection\" ): detect_collisions ()","title":"Using Context Manager"},{"location":"OBSERVABILITY/#using-decorator","text":"from agent.observability import trace_function @trace_function ( \"complex_simulation_step\" ) def run_simulation_step ( agents , environment ): # Function automatically traced # Start and completion logged # Errors automatically captured return process_simulation ( agents , environment )","title":"Using Decorator"},{"location":"OBSERVABILITY/#event-logging","text":"from agent.observability import log_simulation_event # Log simulation events log_simulation_event ( \"agent_created\" , agent_id = 456 , agent_type = \"explorer\" , initial_position = [ 0 , 0 , 0 ]) log_simulation_event ( \"environment_changed\" , change_type = \"temperature\" , old_value = 20.5 , new_value = 25.3 , affected_area = \"sector_7\" )","title":"Event Logging"},{"location":"OBSERVABILITY/#rate-limited-error-logging_1","text":"from agent.observability import log_rate_limited_error # Errors are automatically rate-limited by error key for agent in problematic_agents : log_rate_limited_error ( error_key = \"agent_pathfinding_error\" , message = f \"Agent { agent . id } pathfinding failed\" , agent_id = agent . id , error_count = agent . error_count )","title":"Rate-Limited Error Logging"},{"location":"OBSERVABILITY/#telemetry-integration_1","text":"from agent.telemetry_collector import get_telemetry_collector collector = get_telemetry_collector () # Collect performance metrics (automatically traced) collector . collect_performance_metric ( \"agent_update\" , duration = 0.05 , success = True ) # Collect simulation metrics collector . collect_simulation_metrics ({ \"active_agents\" : 150 , \"average_speed\" : 2.3 , \"collision_rate\" : 0.02 }) # Get comprehensive metrics including observability data metrics = collector . get_current_metrics () print ( f \"Observability metrics: { metrics [ 'observability' ] } \" )","title":"Telemetry Integration"},{"location":"OBSERVABILITY/#configuration","text":"","title":"Configuration"},{"location":"OBSERVABILITY/#log-levels","text":"import logging from agent.observability import initialize_observability # Configure different log levels obs_manager = initialize_observability ( log_level = logging . DEBUG ) # Verbose obs_manager = initialize_observability ( log_level = logging . INFO ) # Standard obs_manager = initialize_observability ( log_level = logging . WARNING ) # Minimal","title":"Log Levels"},{"location":"OBSERVABILITY/#rate-limiting","text":"from agent.observability import ObservabilityManager , RateLimitedErrorLogger obs_manager = ObservabilityManager () # Configure custom rate limits rate_limiter = RateLimitedErrorLogger ( obs_manager . logger , max_errors_per_minute = 5 # Allow 5 errors per minute per error key )","title":"Rate Limiting"},{"location":"OBSERVABILITY/#telemetry-history","text":"from agent.telemetry_collector import initialize_telemetry # Configure telemetry history size collector = initialize_telemetry ( max_history_size = 5000 )","title":"Telemetry History"},{"location":"OBSERVABILITY/#log-format","text":"All logs are output in structured JSON format: { \"timestamp\" : \"2025-09-21T16:30:45.123456Z\" , \"level\" : \"INFO\" , \"logger\" : \"ufog.observability\" , \"message\" : \"Starting traced operation: agent_movement\" , \"module\" : \"main_simulation\" , \"function\" : \"run_simulation_step\" , \"line\" : 42 , \"trace_id\" : \"trace_a1b2c3d4e5f6g7h8\" , \"operation\" : \"agent_movement\" , \"operation_phase\" : \"start\" , \"agent_id\" : 123 , \"position\" : [ 10.5 , 20.3 , 15.7 ] }","title":"Log Format"},{"location":"OBSERVABILITY/#metrics-and-monitoring","text":"","title":"Metrics and Monitoring"},{"location":"OBSERVABILITY/#observability-metrics","text":"from agent.observability import get_metrics_summary metrics = get_metrics_summary () print ( f \"Operations completed: { metrics [ 'operations' ][ 'operations_completed' ] } \" ) print ( f \"Average duration: { metrics [ 'average_operation_duration' ] : .3f } s\" ) print ( f \"Current trace ID: { metrics [ 'current_trace_id' ] } \" )","title":"Observability Metrics"},{"location":"OBSERVABILITY/#performance-monitoring","text":"from agent.telemetry_collector import get_telemetry_collector collector = get_telemetry_collector () performance = collector . get_performance_summary () for operation , stats in performance [ 'performance_metrics' ] . items (): print ( f \" { operation } : { stats [ 'success_rate' ] : .2% } success rate\" ) print ( f \" Average duration: { stats [ 'current_duration' ] : .3f } s\" )","title":"Performance Monitoring"},{"location":"OBSERVABILITY/#integration-with-existing-code","text":"","title":"Integration with Existing Code"},{"location":"OBSERVABILITY/#minimal-integration","text":"# Add to existing functions from agent.observability import trace_function @trace_function () # Uses function name as operation name def existing_function (): # Existing code unchanged pass","title":"Minimal Integration"},{"location":"OBSERVABILITY/#comprehensive-integration","text":"from agent.observability import ( trace_operation , log_simulation_event , log_rate_limited_error , get_observability_manager ) def enhanced_simulation_step (): with trace_operation ( \"simulation_step\" ) as trace_id : log_simulation_event ( \"step_started\" , step_id = current_step ) try : # Existing simulation logic result = run_step_logic () log_simulation_event ( \"step_completed\" , step_id = current_step , agents_processed = len ( result . agents )) return result except Exception as e : log_rate_limited_error ( \"simulation_step_error\" , f \"Step { current_step } failed: { e } \" ) raise","title":"Comprehensive Integration"},{"location":"OBSERVABILITY/#best-practices","text":"","title":"Best Practices"},{"location":"OBSERVABILITY/#1-use-appropriate-log-levels","text":"DEBUG : Detailed diagnostic information INFO : General operational messages WARNING : Potentially problematic situations ERROR : Error conditions that don't stop execution CRITICAL : Serious errors that may stop execution","title":"1. Use Appropriate Log Levels"},{"location":"OBSERVABILITY/#2-include-relevant-context","text":"# Good: Rich context obs . logger . info ( \"Agent state changed\" , agent_id = agent . id , old_state = agent . previous_state , new_state = agent . current_state , trigger = \"collision_detected\" ) # Avoid: Minimal context obs . logger . info ( \"State changed\" )","title":"2. Include Relevant Context"},{"location":"OBSERVABILITY/#3-use-trace-operations-for-performance-critical-code","text":"# Trace expensive operations with trace_operation ( \"pathfinding_calculation\" , agent_count = len ( agents )): paths = calculate_all_paths ( agents , environment )","title":"3. Use Trace Operations for Performance-Critical Code"},{"location":"OBSERVABILITY/#4-leverage-rate-limited-logging-for-frequent-errors","text":"# For errors that might occur frequently for agent in agents : if agent . has_error (): log_rate_limited_error ( error_key = f \"agent_error_ { agent . error_type } \" , message = f \"Agent { agent . id } error: { agent . error_message } \" )","title":"4. Leverage Rate-Limited Logging for Frequent Errors"},{"location":"OBSERVABILITY/#5-use-event-logging-for-state-changes","text":"# Track important state changes log_simulation_event ( \"phase_transition\" , from_phase = \"initialization\" , to_phase = \"simulation\" , duration = init_duration )","title":"5. Use Event Logging for State Changes"},{"location":"OBSERVABILITY/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"OBSERVABILITY/#common-issues","text":"","title":"Common Issues"},{"location":"OBSERVABILITY/#1-missing-trace-ids","text":"Problem : Logs don't contain trace IDs Solution : Ensure operations are wrapped with trace_operation or @trace_function","title":"1. Missing Trace IDs"},{"location":"OBSERVABILITY/#2-performance-impact","text":"Problem : Logging affects simulation performance Solution : Use appropriate log levels and consider async logging for high-frequency operations","title":"2. Performance Impact"},{"location":"OBSERVABILITY/#3-log-volume","text":"Problem : Too many logs generated Solution : Use rate-limited logging and adjust log levels","title":"3. Log Volume"},{"location":"OBSERVABILITY/#debugging","text":"# Enable debug logging import logging from agent.observability import initialize_observability obs = initialize_observability ( log_level = logging . DEBUG ) # Check current configuration metrics = obs . get_metrics_summary () print ( f \"Current configuration: { metrics } \" )","title":"Debugging"},{"location":"OBSERVABILITY/#performance-considerations","text":"Structured logging has minimal overhead (~1-2% in typical scenarios) Trace ID propagation uses thread-local storage for efficiency Rate limiting prevents log spam without losing important information JSON formatting is optimized for both human readability and machine parsing","title":"Performance Considerations"},{"location":"OBSERVABILITY/#future-enhancements","text":"Distributed tracing across multiple processes/services Metrics export to external monitoring systems (Prometheus, etc.) Log aggregation and analysis tools integration Real-time dashboards for simulation monitoring Alerting based on error rates and performance thresholds","title":"Future Enhancements"},{"location":"OBSERVABILITY/#api-reference","text":"","title":"API Reference"},{"location":"OBSERVABILITY/#core-classes","text":"ObservabilityManager : Main orchestrator for all observability features StructuredLogger : JSON-formatted logging with trace propagation TraceContext : Thread-local trace ID management RateLimitedErrorLogger : Intelligent error rate limiting EventLogger : Structured event tracking TracingDecorator : Function tracing decorator TelemetryCollector : Enhanced telemetry with observability integration","title":"Core Classes"},{"location":"OBSERVABILITY/#global-functions","text":"get_observability_manager() : Get global observability manager initialize_observability(log_level) : Initialize observability system trace_operation(name, **context) : Context manager for tracing log_simulation_event(event_type, **data) : Log simulation events log_rate_limited_error(key, message, **kwargs) : Rate-limited error logging trace_function(operation_name) : Function tracing decorator get_metrics_summary() : Get comprehensive metrics summary For detailed API documentation, see the inline docstrings in the source code.","title":"Global Functions"},{"location":"TELEMETRY/","text":"Telemetry System Documentation \u00b6 Overview \u00b6 The UtilityFog telemetry system provides comprehensive metrics collection and export capabilities for monitoring system performance, behavior, and health across the fractal tree network. Architecture \u00b6 Core Components \u00b6 TelemetryCollector : Central hub for metrics collection and event recording MetricsExporter : Abstract interface for exporting metrics in various formats PrometheusAdapter : Prometheus-compatible metrics export Metric Types : Counter, Gauge, and Histogram implementations Key Features \u00b6 Real-time Metrics : Live collection of system performance data Event Recording : Structured event logging with metadata Multiple Export Formats : Prometheus, JSON, and extensible format support System Integration : Built-in hooks for coordination, messaging, and health systems Thread-Safe : Concurrent access support with proper locking Configurable : Flexible collection intervals and export options Usage \u00b6 Basic Setup \u00b6 from utilityfog_frontend.telemetry import TelemetryCollector , PrometheusAdapter # Create collector collector = TelemetryCollector ( collection_interval = 30.0 ) # Register metrics counter = collector . register_counter ( \"requests_total\" , \"Total HTTP requests\" ) gauge = collector . register_gauge ( \"active_connections\" , \"Active connections\" ) histogram = collector . register_histogram ( \"request_duration_seconds\" , \"Request duration\" ) # Start collection await collector . start_collection () Recording Metrics \u00b6 # Increment counter counter . increment () counter . increment ( 5.0 ) # Set gauge value gauge . set ( 42 ) gauge . increment ( 1 ) gauge . decrement ( 2 ) # Record histogram observations histogram . observe ( 0.123 ) histogram . observe ( 0.456 ) Event Recording \u00b6 # Record structured events collector . record_event ( \"user_login\" , { \"user_id\" : \"12345\" , \"timestamp\" : time . time () }, labels = { \"source\" : \"web\" }) collector . record_event ( \"error_occurred\" , { \"error_type\" : \"connection_timeout\" , \"details\" : \"Failed to connect to database\" }) Exporting Metrics \u00b6 # Prometheus export prometheus_exporter = PrometheusAdapter ( \"/tmp/metrics.prom\" ) await prometheus_exporter . export_metrics ( collector ) # JSON export from utilityfog_frontend.telemetry.exporter import JSONExporter json_exporter = JSONExporter ( \"/tmp/metrics.json\" ) await json_exporter . export_metrics ( collector ) System Integration \u00b6 Coordination System Hooks \u00b6 The telemetry system automatically integrates with the coordination system: from utilityfog_frontend.telemetry.collector import setup_coordination_hooks setup_coordination_hooks ( collector ) Metrics Registered: - coordination_messages_total : Total coordination messages - coordination_active_nodes : Number of active coordination nodes - coordination_message_latency_seconds : Coordination message latency Messaging System Hooks \u00b6 Integration with the messaging system: from utilityfog_frontend.telemetry.collector import setup_messaging_hooks setup_messaging_hooks ( collector ) Metrics Registered: - messages_sent_total : Total messages sent - messages_received_total : Total messages received - message_queue_size : Current message queue size - message_processing_duration_seconds : Message processing duration Health System Hooks \u00b6 Integration with health monitoring: from utilityfog_frontend.telemetry.collector import setup_health_hooks setup_health_hooks ( collector ) Metrics Registered: - health_status : Current health status (0=unknown, 1=healthy, 2=degraded, 3=unhealthy) - health_checks_total : Total health checks performed - health_check_duration_seconds : Health check duration Metric Types \u00b6 Counter \u00b6 Monotonically increasing values (e.g., request counts, error counts): counter = collector . register_counter ( \"http_requests_total\" , \"Total HTTP requests\" ) counter . increment () # Increment by 1 counter . increment ( 5.0 ) # Increment by 5 Gauge \u00b6 Values that can increase or decrease (e.g., memory usage, active connections): gauge = collector . register_gauge ( \"memory_usage_bytes\" , \"Memory usage in bytes\" ) gauge . set ( 1024000 ) # Set absolute value gauge . increment ( 100 ) # Increase by 100 gauge . decrement ( 50 ) # Decrease by 50 Histogram \u00b6 Distribution of values (e.g., request durations, response sizes): histogram = collector . register_histogram ( \"request_duration_seconds\" , \"HTTP request duration\" , buckets = [ 0.1 , 0.5 , 1.0 , 2.5 , 5.0 , 10.0 ] ) histogram . observe ( 0.234 ) # Record observation Export Formats \u00b6 Prometheus Format \u00b6 Standard Prometheus text format for scraping: # HELP http_requests_total Total HTTP requests # TYPE http_requests_total counter http_requests_total 1027 # HELP memory_usage_bytes Memory usage in bytes # TYPE memory_usage_bytes gauge memory_usage_bytes 1048576 JSON Format \u00b6 Structured JSON for programmatic consumption: { \"timestamp\" : 1632150000.0 , \"metrics\" : { \"http_requests_total\" : { \"value\" : 1027 , \"labels\" : {}, \"timestamp\" : 1632150000.0 } }, \"events_count\" : 150 , \"running\" : true } Configuration \u00b6 Collection Interval \u00b6 Configure how often metrics are collected: collector = TelemetryCollector ( collection_interval = 60.0 ) # 60 seconds Custom Buckets \u00b6 Configure histogram buckets for your use case: histogram = collector . register_histogram ( \"api_response_time\" , \"API response time distribution\" , buckets = [ 0.001 , 0.01 , 0.1 , 0.5 , 1.0 , 5.0 ] # Custom buckets ) Periodic Export \u00b6 Set up automatic periodic export: from utilityfog_frontend.telemetry.exporter import PeriodicExporter exporter = PrometheusAdapter ( \"/var/metrics/prometheus.txt\" ) periodic_exporter = PeriodicExporter ( exporter , collector , interval = 30.0 ) await periodic_exporter . start () Best Practices \u00b6 Metric Naming \u00b6 Use descriptive names with units: request_duration_seconds , memory_usage_bytes Follow Prometheus naming conventions: subsystem_metric_unit Use consistent labeling: {method=\"GET\", status=\"200\"} Performance Considerations \u00b6 Use appropriate metric types for your data Avoid high-cardinality labels (many unique values) Configure reasonable collection intervals Monitor memory usage with many metrics Error Handling \u00b6 The telemetry system is designed to be resilient: Failed metric operations are logged but don't crash the system Export failures are retried automatically Thread-safe operations prevent data corruption Monitoring and Alerting \u00b6 Key Metrics to Monitor \u00b6 telemetry_collection_runs_total : Collection health telemetry_collection_duration_seconds : Collection performance telemetry_metrics_count : Number of registered metrics telemetry_events_total : Event recording rate Sample Alerts \u00b6 # Prometheus alerting rules groups : - name : telemetry rules : - alert : TelemetryCollectionFailed expr : increase(telemetry_collection_runs_total[5m]) == 0 for : 2m annotations : summary : \"Telemetry collection has stopped\" - alert : HighTelemetryCollectionDuration expr : telemetry_collection_duration_seconds > 10 for : 1m annotations : summary : \"Telemetry collection taking too long\" API Reference \u00b6 TelemetryCollector \u00b6 Main class for metrics collection and management. Methods \u00b6 register_counter(name, description, labels) : Register a counter metric register_gauge(name, description, labels) : Register a gauge metric register_histogram(name, description, buckets, labels) : Register a histogram metric get_metric(name) : Retrieve a registered metric record_event(name, value, labels, metadata) : Record a telemetry event add_hook(hook_type, callback) : Add event hook start_collection() : Start periodic collection stop_collection() : Stop periodic collection get_snapshot() : Get current telemetry snapshot MetricsExporter \u00b6 Abstract base class for metrics exporters. Implementations \u00b6 PrometheusAdapter : Prometheus text format export JSONExporter : JSON format export MultiExporter : Multiple format export PeriodicExporter : Automatic periodic export Troubleshooting \u00b6 Common Issues \u00b6 Metrics not updating : Check if collection is started with start_collection() Export failures : Verify file permissions and disk space High memory usage : Review metric cardinality and event retention Thread safety issues : Use the provided thread-safe metric operations Debug Information \u00b6 Enable debug logging to troubleshoot issues: import logging logging . getLogger ( 'utilityfog_frontend.telemetry' ) . setLevel ( logging . DEBUG ) Performance Tuning \u00b6 Adjust collection interval based on your needs Use appropriate histogram buckets for your data distribution Limit event retention with reasonable buffer sizes Monitor system resource usage Future Enhancements \u00b6 Remote Export : HTTP endpoints for metrics scraping Alerting Integration : Built-in alerting rules and notifications Dashboard Integration : Grafana dashboard templates Advanced Analytics : Statistical analysis and anomaly detection Distributed Tracing : OpenTelemetry integration for request tracing","title":"Telemetry System Documentation"},{"location":"TELEMETRY/#telemetry-system-documentation","text":"","title":"Telemetry System Documentation"},{"location":"TELEMETRY/#overview","text":"The UtilityFog telemetry system provides comprehensive metrics collection and export capabilities for monitoring system performance, behavior, and health across the fractal tree network.","title":"Overview"},{"location":"TELEMETRY/#architecture","text":"","title":"Architecture"},{"location":"TELEMETRY/#core-components","text":"TelemetryCollector : Central hub for metrics collection and event recording MetricsExporter : Abstract interface for exporting metrics in various formats PrometheusAdapter : Prometheus-compatible metrics export Metric Types : Counter, Gauge, and Histogram implementations","title":"Core Components"},{"location":"TELEMETRY/#key-features","text":"Real-time Metrics : Live collection of system performance data Event Recording : Structured event logging with metadata Multiple Export Formats : Prometheus, JSON, and extensible format support System Integration : Built-in hooks for coordination, messaging, and health systems Thread-Safe : Concurrent access support with proper locking Configurable : Flexible collection intervals and export options","title":"Key Features"},{"location":"TELEMETRY/#usage","text":"","title":"Usage"},{"location":"TELEMETRY/#basic-setup","text":"from utilityfog_frontend.telemetry import TelemetryCollector , PrometheusAdapter # Create collector collector = TelemetryCollector ( collection_interval = 30.0 ) # Register metrics counter = collector . register_counter ( \"requests_total\" , \"Total HTTP requests\" ) gauge = collector . register_gauge ( \"active_connections\" , \"Active connections\" ) histogram = collector . register_histogram ( \"request_duration_seconds\" , \"Request duration\" ) # Start collection await collector . start_collection ()","title":"Basic Setup"},{"location":"TELEMETRY/#recording-metrics","text":"# Increment counter counter . increment () counter . increment ( 5.0 ) # Set gauge value gauge . set ( 42 ) gauge . increment ( 1 ) gauge . decrement ( 2 ) # Record histogram observations histogram . observe ( 0.123 ) histogram . observe ( 0.456 )","title":"Recording Metrics"},{"location":"TELEMETRY/#event-recording","text":"# Record structured events collector . record_event ( \"user_login\" , { \"user_id\" : \"12345\" , \"timestamp\" : time . time () }, labels = { \"source\" : \"web\" }) collector . record_event ( \"error_occurred\" , { \"error_type\" : \"connection_timeout\" , \"details\" : \"Failed to connect to database\" })","title":"Event Recording"},{"location":"TELEMETRY/#exporting-metrics","text":"# Prometheus export prometheus_exporter = PrometheusAdapter ( \"/tmp/metrics.prom\" ) await prometheus_exporter . export_metrics ( collector ) # JSON export from utilityfog_frontend.telemetry.exporter import JSONExporter json_exporter = JSONExporter ( \"/tmp/metrics.json\" ) await json_exporter . export_metrics ( collector )","title":"Exporting Metrics"},{"location":"TELEMETRY/#system-integration","text":"","title":"System Integration"},{"location":"TELEMETRY/#coordination-system-hooks","text":"The telemetry system automatically integrates with the coordination system: from utilityfog_frontend.telemetry.collector import setup_coordination_hooks setup_coordination_hooks ( collector ) Metrics Registered: - coordination_messages_total : Total coordination messages - coordination_active_nodes : Number of active coordination nodes - coordination_message_latency_seconds : Coordination message latency","title":"Coordination System Hooks"},{"location":"TELEMETRY/#messaging-system-hooks","text":"Integration with the messaging system: from utilityfog_frontend.telemetry.collector import setup_messaging_hooks setup_messaging_hooks ( collector ) Metrics Registered: - messages_sent_total : Total messages sent - messages_received_total : Total messages received - message_queue_size : Current message queue size - message_processing_duration_seconds : Message processing duration","title":"Messaging System Hooks"},{"location":"TELEMETRY/#health-system-hooks","text":"Integration with health monitoring: from utilityfog_frontend.telemetry.collector import setup_health_hooks setup_health_hooks ( collector ) Metrics Registered: - health_status : Current health status (0=unknown, 1=healthy, 2=degraded, 3=unhealthy) - health_checks_total : Total health checks performed - health_check_duration_seconds : Health check duration","title":"Health System Hooks"},{"location":"TELEMETRY/#metric-types","text":"","title":"Metric Types"},{"location":"TELEMETRY/#counter","text":"Monotonically increasing values (e.g., request counts, error counts): counter = collector . register_counter ( \"http_requests_total\" , \"Total HTTP requests\" ) counter . increment () # Increment by 1 counter . increment ( 5.0 ) # Increment by 5","title":"Counter"},{"location":"TELEMETRY/#gauge","text":"Values that can increase or decrease (e.g., memory usage, active connections): gauge = collector . register_gauge ( \"memory_usage_bytes\" , \"Memory usage in bytes\" ) gauge . set ( 1024000 ) # Set absolute value gauge . increment ( 100 ) # Increase by 100 gauge . decrement ( 50 ) # Decrease by 50","title":"Gauge"},{"location":"TELEMETRY/#histogram","text":"Distribution of values (e.g., request durations, response sizes): histogram = collector . register_histogram ( \"request_duration_seconds\" , \"HTTP request duration\" , buckets = [ 0.1 , 0.5 , 1.0 , 2.5 , 5.0 , 10.0 ] ) histogram . observe ( 0.234 ) # Record observation","title":"Histogram"},{"location":"TELEMETRY/#export-formats","text":"","title":"Export Formats"},{"location":"TELEMETRY/#prometheus-format","text":"Standard Prometheus text format for scraping: # HELP http_requests_total Total HTTP requests # TYPE http_requests_total counter http_requests_total 1027 # HELP memory_usage_bytes Memory usage in bytes # TYPE memory_usage_bytes gauge memory_usage_bytes 1048576","title":"Prometheus Format"},{"location":"TELEMETRY/#json-format","text":"Structured JSON for programmatic consumption: { \"timestamp\" : 1632150000.0 , \"metrics\" : { \"http_requests_total\" : { \"value\" : 1027 , \"labels\" : {}, \"timestamp\" : 1632150000.0 } }, \"events_count\" : 150 , \"running\" : true }","title":"JSON Format"},{"location":"TELEMETRY/#configuration","text":"","title":"Configuration"},{"location":"TELEMETRY/#collection-interval","text":"Configure how often metrics are collected: collector = TelemetryCollector ( collection_interval = 60.0 ) # 60 seconds","title":"Collection Interval"},{"location":"TELEMETRY/#custom-buckets","text":"Configure histogram buckets for your use case: histogram = collector . register_histogram ( \"api_response_time\" , \"API response time distribution\" , buckets = [ 0.001 , 0.01 , 0.1 , 0.5 , 1.0 , 5.0 ] # Custom buckets )","title":"Custom Buckets"},{"location":"TELEMETRY/#periodic-export","text":"Set up automatic periodic export: from utilityfog_frontend.telemetry.exporter import PeriodicExporter exporter = PrometheusAdapter ( \"/var/metrics/prometheus.txt\" ) periodic_exporter = PeriodicExporter ( exporter , collector , interval = 30.0 ) await periodic_exporter . start ()","title":"Periodic Export"},{"location":"TELEMETRY/#best-practices","text":"","title":"Best Practices"},{"location":"TELEMETRY/#metric-naming","text":"Use descriptive names with units: request_duration_seconds , memory_usage_bytes Follow Prometheus naming conventions: subsystem_metric_unit Use consistent labeling: {method=\"GET\", status=\"200\"}","title":"Metric Naming"},{"location":"TELEMETRY/#performance-considerations","text":"Use appropriate metric types for your data Avoid high-cardinality labels (many unique values) Configure reasonable collection intervals Monitor memory usage with many metrics","title":"Performance Considerations"},{"location":"TELEMETRY/#error-handling","text":"The telemetry system is designed to be resilient: Failed metric operations are logged but don't crash the system Export failures are retried automatically Thread-safe operations prevent data corruption","title":"Error Handling"},{"location":"TELEMETRY/#monitoring-and-alerting","text":"","title":"Monitoring and Alerting"},{"location":"TELEMETRY/#key-metrics-to-monitor","text":"telemetry_collection_runs_total : Collection health telemetry_collection_duration_seconds : Collection performance telemetry_metrics_count : Number of registered metrics telemetry_events_total : Event recording rate","title":"Key Metrics to Monitor"},{"location":"TELEMETRY/#sample-alerts","text":"# Prometheus alerting rules groups : - name : telemetry rules : - alert : TelemetryCollectionFailed expr : increase(telemetry_collection_runs_total[5m]) == 0 for : 2m annotations : summary : \"Telemetry collection has stopped\" - alert : HighTelemetryCollectionDuration expr : telemetry_collection_duration_seconds > 10 for : 1m annotations : summary : \"Telemetry collection taking too long\"","title":"Sample Alerts"},{"location":"TELEMETRY/#api-reference","text":"","title":"API Reference"},{"location":"TELEMETRY/#telemetrycollector","text":"Main class for metrics collection and management.","title":"TelemetryCollector"},{"location":"TELEMETRY/#methods","text":"register_counter(name, description, labels) : Register a counter metric register_gauge(name, description, labels) : Register a gauge metric register_histogram(name, description, buckets, labels) : Register a histogram metric get_metric(name) : Retrieve a registered metric record_event(name, value, labels, metadata) : Record a telemetry event add_hook(hook_type, callback) : Add event hook start_collection() : Start periodic collection stop_collection() : Stop periodic collection get_snapshot() : Get current telemetry snapshot","title":"Methods"},{"location":"TELEMETRY/#metricsexporter","text":"Abstract base class for metrics exporters.","title":"MetricsExporter"},{"location":"TELEMETRY/#implementations","text":"PrometheusAdapter : Prometheus text format export JSONExporter : JSON format export MultiExporter : Multiple format export PeriodicExporter : Automatic periodic export","title":"Implementations"},{"location":"TELEMETRY/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"TELEMETRY/#common-issues","text":"Metrics not updating : Check if collection is started with start_collection() Export failures : Verify file permissions and disk space High memory usage : Review metric cardinality and event retention Thread safety issues : Use the provided thread-safe metric operations","title":"Common Issues"},{"location":"TELEMETRY/#debug-information","text":"Enable debug logging to troubleshoot issues: import logging logging . getLogger ( 'utilityfog_frontend.telemetry' ) . setLevel ( logging . DEBUG )","title":"Debug Information"},{"location":"TELEMETRY/#performance-tuning","text":"Adjust collection interval based on your needs Use appropriate histogram buckets for your data distribution Limit event retention with reasonable buffer sizes Monitor system resource usage","title":"Performance Tuning"},{"location":"TELEMETRY/#future-enhancements","text":"Remote Export : HTTP endpoints for metrics scraping Alerting Integration : Built-in alerting rules and notifications Dashboard Integration : Grafana dashboard templates Advanced Analytics : Statistical analysis and anomaly detection Distributed Tracing : OpenTelemetry integration for request tracing","title":"Future Enhancements"},{"location":"VISUALIZATION/","text":"CLI Visualization System Documentation \u00b6 Overview \u00b6 The UtilityFog CLI Visualization system provides comprehensive command-line tools for visualizing fractal tree structures, message flows, and state transitions. It supports multiple rendering modes, interactive visualization, and export to various formats including HTML, SVG, and JSON. Architecture \u00b6 Core Components \u00b6 Data Models : TreeNode, MessageFlow, StateTransition, VisualizationData Renderers : TreeRenderer, FlowRenderer, StateRenderer, InteractiveRenderer Exporters : HTMLExporter, SVGExporter, TextExporter, JSONExporter CLI Interface : VisualizationCLI with command-line argument parsing Key Features \u00b6 Multiple Visualization Types : Tree structure, message flows, state transitions Interactive Mode : Real-time visualization with keyboard navigation Export Formats : HTML reports, SVG diagrams, plain text, JSON data Customizable Display : Color schemes, dimensions, time windows Demo Data Generation : Built-in sample data generator for testing Usage \u00b6 Installation \u00b6 The CLI visualization system is part of the UtilityFog frontend package: # Install dependencies pip install -r requirements.txt # Run from the project root python -m utilityfog_frontend.cli_viz --help Basic Commands \u00b6 Tree Structure Visualization \u00b6 Display the hierarchical structure of nodes: # Basic tree view python -m utilityfog_frontend.cli_viz tree --input data.json # Customized tree view python -m utilityfog_frontend.cli_viz tree \\ --input data.json \\ --width 120 \\ --height 40 \\ --color-scheme dark \\ --show-ids Message Flow Visualization \u00b6 Display message flows between nodes: # Basic flow view python -m utilityfog_frontend.cli_viz flow --input data.json # Flow view with time window python -m utilityfog_frontend.cli_viz flow \\ --input data.json \\ --time-window 300 \\ --color-scheme colorblind State Transition Visualization \u00b6 Display state changes over time: # Basic state view python -m utilityfog_frontend.cli_viz state --input data.json # State view with extended time window python -m utilityfog_frontend.cli_viz state \\ --input data.json \\ --time-window 600 Interactive Mode \u00b6 Real-time visualization with keyboard controls: # Interactive mode python -m utilityfog_frontend.cli_viz interactive \\ --input data.json \\ --refresh-rate 2 .0 # Controls: # [t] - Switch to tree view # [f] - Switch to flow view # [s] - Switch to state view # [r] - Refresh data # [q] - Quit Export Functionality \u00b6 HTML Report Export \u00b6 Generate interactive HTML reports: # Basic HTML export python -m utilityfog_frontend.cli_viz export \\ --input data.json \\ --output report.html \\ --format html The HTML export includes: - Interactive tabbed interface - Tree structure with expandable nodes - Message flow timeline - State transition history - Statistics dashboard - Responsive design with CSS styling SVG Diagram Export \u00b6 Generate scalable vector graphics: # SVG export with custom dimensions python -m utilityfog_frontend.cli_viz export \\ --input data.json \\ --output diagram.svg \\ --format svg \\ --width 1200 \\ --height 800 Text Report Export \u00b6 Generate plain text reports: # Text export python -m utilityfog_frontend.cli_viz export \\ --input data.json \\ --output report.txt \\ --format text JSON Data Export \u00b6 Export processed visualization data: # JSON export python -m utilityfog_frontend.cli_viz export \\ --input data.json \\ --output processed.json \\ --format json Demo Data Generation \u00b6 Generate sample data for testing: # Generate demo data python -m utilityfog_frontend.cli_viz demo \\ --nodes 20 \\ --messages 50 \\ --transitions 30 \\ --output demo_data.json Data Format \u00b6 Input JSON Structure \u00b6 The visualization system expects JSON data in the following format: { \"timestamp\" : 1632150000.0 , \"nodes\" : { \"node_001\" : { \"id\" : \"node_001\" , \"name\" : \"Root Node\" , \"state\" : \"active\" , \"parent_id\" : null , \"children\" : [ \"node_002\" , \"node_003\" ], \"position\" : [ 400 , 100 ], \"metadata\" : { \"cpu_usage\" : 45.2 , \"memory_mb\" : 512 }, \"last_updated\" : 1632149900.0 } }, \"messages\" : [ { \"id\" : \"msg_001\" , \"source_id\" : \"node_001\" , \"target_id\" : \"node_002\" , \"message_type\" : \"coordination\" , \"content\" : \"heartbeat\" , \"timestamp\" : 1632149950.0 , \"status\" : \"delivered\" , \"metadata\" : { \"size_bytes\" : 256 } } ], \"transitions\" : [ { \"node_id\" : \"node_002\" , \"from_state\" : \"inactive\" , \"to_state\" : \"active\" , \"timestamp\" : 1632149900.0 , \"trigger\" : \"heartbeat\" , \"metadata\" : { \"duration_ms\" : 150 } } ], \"metadata\" : { \"version\" : \"1.0\" , \"source\" : \"simulation\" } } Node States \u00b6 Supported node states: - active : Node is operational and processing - inactive : Node is idle or offline - processing : Node is actively processing tasks - error : Node has encountered an error - unknown : Node state is undetermined Message Types \u00b6 Supported message types: - coordination : Coordination protocol messages - data : Data transfer messages - heartbeat : Health check messages - error : Error notification messages - control : Control and command messages Rendering Options \u00b6 Color Schemes \u00b6 Default Scheme \u00b6 Active: Green Inactive: Gray Processing: Yellow Error: Red Unknown: Blue Dark Scheme \u00b6 Optimized for dark terminals High contrast colors Bright accent colors Colorblind Scheme \u00b6 Colorblind-friendly palette Distinct patterns and symbols Accessible color combinations Display Customization \u00b6 Tree Renderer Options \u00b6 width : Display width in characters (default: 80) height : Display height in lines (default: 24) show_ids : Show node IDs alongside names color_scheme : Color scheme selection Flow Renderer Options \u00b6 time_window : Time window for message display (seconds) Message status indicators Flow direction arrows Timestamp information State Renderer Options \u00b6 time_window : Time window for transition display (seconds) State change indicators Transition triggers Duration information Integration \u00b6 System Integration \u00b6 The CLI visualization system integrates with other UtilityFog components: from utilityfog_frontend.cli_viz import VisualizationData , TreeNode , MessageFlow # Create visualization data viz_data = VisualizationData () # Add nodes from coordination system for node_id , node_info in coordination_system . get_nodes (): tree_node = TreeNode ( id = node_id , name = node_info . name , state = NodeState ( node_info . status ), metadata = node_info . metrics ) viz_data . add_node ( tree_node ) # Add messages from messaging system for message in messaging_system . get_recent_messages (): flow = MessageFlow ( id = message . id , source_id = message . sender , target_id = message . receiver , message_type = MessageType ( message . type ), content = message . payload ) viz_data . add_message ( flow ) Telemetry Integration \u00b6 Integration with the telemetry system (FT-008): from utilityfog_frontend.telemetry import TelemetryCollector from utilityfog_frontend.cli_viz import VisualizationData def create_viz_from_telemetry ( collector : TelemetryCollector ) -> VisualizationData : \"\"\"Create visualization data from telemetry collector.\"\"\" viz_data = VisualizationData () # Extract node information from metrics snapshot = collector . get_snapshot () # Convert telemetry events to visualization events for event in collector . get_events (): if event . name == \"node_state_change\" : transition = StateTransition ( node_id = event . value [ \"node_id\" ], from_state = NodeState ( event . value [ \"from_state\" ]), to_state = NodeState ( event . value [ \"to_state\" ]), timestamp = event . timestamp , trigger = event . value . get ( \"trigger\" , \"unknown\" ) ) viz_data . add_transition ( transition ) return viz_data Advanced Features \u00b6 Custom Renderers \u00b6 Create custom renderers for specialized visualization needs: from utilityfog_frontend.cli_viz.renderer import BaseRenderer class CustomRenderer ( BaseRenderer ): \"\"\"Custom renderer for specialized visualization.\"\"\" def render ( self , data : VisualizationData ) -> str : \"\"\"Render custom visualization.\"\"\" lines = [] lines . append ( \"CUSTOM VISUALIZATION\" ) lines . append ( \"=\" * self . width ) # Custom rendering logic for node in data . nodes . values (): lines . append ( f \"Node: { node . name } ( { node . state . value } )\" ) return \" \\n \" . join ( lines ) Custom Exporters \u00b6 Create custom exporters for specialized output formats: from utilityfog_frontend.cli_viz.exporters import BaseExporter class CustomExporter ( BaseExporter ): \"\"\"Custom exporter for specialized format.\"\"\" def export ( self , data : VisualizationData , output_path : str ) -> bool : \"\"\"Export to custom format.\"\"\" try : # Custom export logic with open ( output_path , 'w' ) as f : f . write ( \"Custom format data \\n \" ) for node in data . nodes . values (): f . write ( f \" { node . id } , { node . name } , { node . state . value } \\n \" ) return True except Exception as e : print ( f \"Export error: { e } \" ) return False Programmatic Usage \u00b6 Use the visualization system programmatically: import asyncio from utilityfog_frontend.cli_viz import VisualizationCLI async def automated_visualization (): \"\"\"Automated visualization workflow.\"\"\" cli = VisualizationCLI () # Generate demo data demo_args = type ( 'Args' , (), { 'nodes' : 15 , 'messages' : 30 , 'transitions' : 20 , 'output' : 'auto_demo.json' })() cli . cmd_demo ( demo_args ) # Export HTML report export_args = type ( 'Args' , (), { 'input' : 'auto_demo.json' , 'output' : 'auto_report.html' , 'format' : 'html' , 'width' : 800 , 'height' : 600 })() cli . cmd_export ( export_args ) print ( \"Automated visualization complete\" ) # Run automated workflow asyncio . run ( automated_visualization ()) Performance Considerations \u00b6 Memory Usage \u00b6 Node data is kept in memory for fast access Message and transition history is limited (configurable) Large datasets may require data streaming or pagination Rendering Performance \u00b6 ASCII rendering is optimized for terminal display SVG generation scales with node count HTML export includes embedded CSS/JS for self-contained reports Interactive Mode \u00b6 Refresh rate affects CPU usage Terminal I/O may have platform-specific limitations Large datasets may cause display lag Troubleshooting \u00b6 Common Issues \u00b6 Import Errors : Ensure all dependencies are installed File Not Found : Check input file paths and permissions Display Issues : Verify terminal size and color support Interactive Mode : Requires Unix-like system with termios Debug Mode \u00b6 Enable debug output for troubleshooting: import logging logging . getLogger ( 'utilityfog_frontend.cli_viz' ) . setLevel ( logging . DEBUG ) Performance Tuning \u00b6 Reduce time windows for large datasets Use appropriate display dimensions Limit node metadata for better performance API Reference \u00b6 Core Classes \u00b6 VisualizationData \u00b6 Container for all visualization data. Methods: - add_node(node) : Add a tree node - add_message(message) : Add a message flow - add_transition(transition) : Add a state transition - get_active_nodes() : Get nodes in active state - get_recent_messages(seconds) : Get recent messages - get_node_hierarchy() : Get hierarchical structure TreeNode \u00b6 Represents a node in the fractal tree. Properties: - id : Unique node identifier - name : Display name - state : Current node state - parent_id : Parent node ID - children : List of child node IDs - metadata : Additional node data MessageFlow \u00b6 Represents a message between nodes. Properties: - source_id : Source node ID - target_id : Target node ID - message_type : Type of message - content : Message content - status : Delivery status StateTransition \u00b6 Represents a state change event. Properties: - node_id : Node that changed state - from_state : Previous state - to_state : New state - trigger : What caused the transition Renderers \u00b6 TreeRenderer \u00b6 Renders hierarchical tree structure. FlowRenderer \u00b6 Renders message flows between nodes. StateRenderer \u00b6 Renders state transitions over time. InteractiveRenderer \u00b6 Provides interactive real-time visualization. Exporters \u00b6 HTMLExporter \u00b6 Exports interactive HTML reports. SVGExporter \u00b6 Exports scalable vector graphics. TextExporter \u00b6 Exports plain text reports. JSONExporter \u00b6 Exports structured JSON data. Future Enhancements \u00b6 3D Visualization : WebGL-based 3D tree rendering Real-time Streaming : Live data feed integration Advanced Analytics : Statistical analysis and pattern detection Custom Themes : User-defined color schemes and layouts Plugin System : Extensible renderer and exporter plugins Performance Optimization : Lazy loading and data virtualization Mobile Support : Responsive design for mobile devices Collaboration Features : Shared visualization sessions","title":"CLI Visualization System Documentation"},{"location":"VISUALIZATION/#cli-visualization-system-documentation","text":"","title":"CLI Visualization System Documentation"},{"location":"VISUALIZATION/#overview","text":"The UtilityFog CLI Visualization system provides comprehensive command-line tools for visualizing fractal tree structures, message flows, and state transitions. It supports multiple rendering modes, interactive visualization, and export to various formats including HTML, SVG, and JSON.","title":"Overview"},{"location":"VISUALIZATION/#architecture","text":"","title":"Architecture"},{"location":"VISUALIZATION/#core-components","text":"Data Models : TreeNode, MessageFlow, StateTransition, VisualizationData Renderers : TreeRenderer, FlowRenderer, StateRenderer, InteractiveRenderer Exporters : HTMLExporter, SVGExporter, TextExporter, JSONExporter CLI Interface : VisualizationCLI with command-line argument parsing","title":"Core Components"},{"location":"VISUALIZATION/#key-features","text":"Multiple Visualization Types : Tree structure, message flows, state transitions Interactive Mode : Real-time visualization with keyboard navigation Export Formats : HTML reports, SVG diagrams, plain text, JSON data Customizable Display : Color schemes, dimensions, time windows Demo Data Generation : Built-in sample data generator for testing","title":"Key Features"},{"location":"VISUALIZATION/#usage","text":"","title":"Usage"},{"location":"VISUALIZATION/#installation","text":"The CLI visualization system is part of the UtilityFog frontend package: # Install dependencies pip install -r requirements.txt # Run from the project root python -m utilityfog_frontend.cli_viz --help","title":"Installation"},{"location":"VISUALIZATION/#basic-commands","text":"","title":"Basic Commands"},{"location":"VISUALIZATION/#tree-structure-visualization","text":"Display the hierarchical structure of nodes: # Basic tree view python -m utilityfog_frontend.cli_viz tree --input data.json # Customized tree view python -m utilityfog_frontend.cli_viz tree \\ --input data.json \\ --width 120 \\ --height 40 \\ --color-scheme dark \\ --show-ids","title":"Tree Structure Visualization"},{"location":"VISUALIZATION/#message-flow-visualization","text":"Display message flows between nodes: # Basic flow view python -m utilityfog_frontend.cli_viz flow --input data.json # Flow view with time window python -m utilityfog_frontend.cli_viz flow \\ --input data.json \\ --time-window 300 \\ --color-scheme colorblind","title":"Message Flow Visualization"},{"location":"VISUALIZATION/#state-transition-visualization","text":"Display state changes over time: # Basic state view python -m utilityfog_frontend.cli_viz state --input data.json # State view with extended time window python -m utilityfog_frontend.cli_viz state \\ --input data.json \\ --time-window 600","title":"State Transition Visualization"},{"location":"VISUALIZATION/#interactive-mode","text":"Real-time visualization with keyboard controls: # Interactive mode python -m utilityfog_frontend.cli_viz interactive \\ --input data.json \\ --refresh-rate 2 .0 # Controls: # [t] - Switch to tree view # [f] - Switch to flow view # [s] - Switch to state view # [r] - Refresh data # [q] - Quit","title":"Interactive Mode"},{"location":"VISUALIZATION/#export-functionality","text":"","title":"Export Functionality"},{"location":"VISUALIZATION/#html-report-export","text":"Generate interactive HTML reports: # Basic HTML export python -m utilityfog_frontend.cli_viz export \\ --input data.json \\ --output report.html \\ --format html The HTML export includes: - Interactive tabbed interface - Tree structure with expandable nodes - Message flow timeline - State transition history - Statistics dashboard - Responsive design with CSS styling","title":"HTML Report Export"},{"location":"VISUALIZATION/#svg-diagram-export","text":"Generate scalable vector graphics: # SVG export with custom dimensions python -m utilityfog_frontend.cli_viz export \\ --input data.json \\ --output diagram.svg \\ --format svg \\ --width 1200 \\ --height 800","title":"SVG Diagram Export"},{"location":"VISUALIZATION/#text-report-export","text":"Generate plain text reports: # Text export python -m utilityfog_frontend.cli_viz export \\ --input data.json \\ --output report.txt \\ --format text","title":"Text Report Export"},{"location":"VISUALIZATION/#json-data-export","text":"Export processed visualization data: # JSON export python -m utilityfog_frontend.cli_viz export \\ --input data.json \\ --output processed.json \\ --format json","title":"JSON Data Export"},{"location":"VISUALIZATION/#demo-data-generation","text":"Generate sample data for testing: # Generate demo data python -m utilityfog_frontend.cli_viz demo \\ --nodes 20 \\ --messages 50 \\ --transitions 30 \\ --output demo_data.json","title":"Demo Data Generation"},{"location":"VISUALIZATION/#data-format","text":"","title":"Data Format"},{"location":"VISUALIZATION/#input-json-structure","text":"The visualization system expects JSON data in the following format: { \"timestamp\" : 1632150000.0 , \"nodes\" : { \"node_001\" : { \"id\" : \"node_001\" , \"name\" : \"Root Node\" , \"state\" : \"active\" , \"parent_id\" : null , \"children\" : [ \"node_002\" , \"node_003\" ], \"position\" : [ 400 , 100 ], \"metadata\" : { \"cpu_usage\" : 45.2 , \"memory_mb\" : 512 }, \"last_updated\" : 1632149900.0 } }, \"messages\" : [ { \"id\" : \"msg_001\" , \"source_id\" : \"node_001\" , \"target_id\" : \"node_002\" , \"message_type\" : \"coordination\" , \"content\" : \"heartbeat\" , \"timestamp\" : 1632149950.0 , \"status\" : \"delivered\" , \"metadata\" : { \"size_bytes\" : 256 } } ], \"transitions\" : [ { \"node_id\" : \"node_002\" , \"from_state\" : \"inactive\" , \"to_state\" : \"active\" , \"timestamp\" : 1632149900.0 , \"trigger\" : \"heartbeat\" , \"metadata\" : { \"duration_ms\" : 150 } } ], \"metadata\" : { \"version\" : \"1.0\" , \"source\" : \"simulation\" } }","title":"Input JSON Structure"},{"location":"VISUALIZATION/#node-states","text":"Supported node states: - active : Node is operational and processing - inactive : Node is idle or offline - processing : Node is actively processing tasks - error : Node has encountered an error - unknown : Node state is undetermined","title":"Node States"},{"location":"VISUALIZATION/#message-types","text":"Supported message types: - coordination : Coordination protocol messages - data : Data transfer messages - heartbeat : Health check messages - error : Error notification messages - control : Control and command messages","title":"Message Types"},{"location":"VISUALIZATION/#rendering-options","text":"","title":"Rendering Options"},{"location":"VISUALIZATION/#color-schemes","text":"","title":"Color Schemes"},{"location":"VISUALIZATION/#default-scheme","text":"Active: Green Inactive: Gray Processing: Yellow Error: Red Unknown: Blue","title":"Default Scheme"},{"location":"VISUALIZATION/#dark-scheme","text":"Optimized for dark terminals High contrast colors Bright accent colors","title":"Dark Scheme"},{"location":"VISUALIZATION/#colorblind-scheme","text":"Colorblind-friendly palette Distinct patterns and symbols Accessible color combinations","title":"Colorblind Scheme"},{"location":"VISUALIZATION/#display-customization","text":"","title":"Display Customization"},{"location":"VISUALIZATION/#tree-renderer-options","text":"width : Display width in characters (default: 80) height : Display height in lines (default: 24) show_ids : Show node IDs alongside names color_scheme : Color scheme selection","title":"Tree Renderer Options"},{"location":"VISUALIZATION/#flow-renderer-options","text":"time_window : Time window for message display (seconds) Message status indicators Flow direction arrows Timestamp information","title":"Flow Renderer Options"},{"location":"VISUALIZATION/#state-renderer-options","text":"time_window : Time window for transition display (seconds) State change indicators Transition triggers Duration information","title":"State Renderer Options"},{"location":"VISUALIZATION/#integration","text":"","title":"Integration"},{"location":"VISUALIZATION/#system-integration","text":"The CLI visualization system integrates with other UtilityFog components: from utilityfog_frontend.cli_viz import VisualizationData , TreeNode , MessageFlow # Create visualization data viz_data = VisualizationData () # Add nodes from coordination system for node_id , node_info in coordination_system . get_nodes (): tree_node = TreeNode ( id = node_id , name = node_info . name , state = NodeState ( node_info . status ), metadata = node_info . metrics ) viz_data . add_node ( tree_node ) # Add messages from messaging system for message in messaging_system . get_recent_messages (): flow = MessageFlow ( id = message . id , source_id = message . sender , target_id = message . receiver , message_type = MessageType ( message . type ), content = message . payload ) viz_data . add_message ( flow )","title":"System Integration"},{"location":"VISUALIZATION/#telemetry-integration","text":"Integration with the telemetry system (FT-008): from utilityfog_frontend.telemetry import TelemetryCollector from utilityfog_frontend.cli_viz import VisualizationData def create_viz_from_telemetry ( collector : TelemetryCollector ) -> VisualizationData : \"\"\"Create visualization data from telemetry collector.\"\"\" viz_data = VisualizationData () # Extract node information from metrics snapshot = collector . get_snapshot () # Convert telemetry events to visualization events for event in collector . get_events (): if event . name == \"node_state_change\" : transition = StateTransition ( node_id = event . value [ \"node_id\" ], from_state = NodeState ( event . value [ \"from_state\" ]), to_state = NodeState ( event . value [ \"to_state\" ]), timestamp = event . timestamp , trigger = event . value . get ( \"trigger\" , \"unknown\" ) ) viz_data . add_transition ( transition ) return viz_data","title":"Telemetry Integration"},{"location":"VISUALIZATION/#advanced-features","text":"","title":"Advanced Features"},{"location":"VISUALIZATION/#custom-renderers","text":"Create custom renderers for specialized visualization needs: from utilityfog_frontend.cli_viz.renderer import BaseRenderer class CustomRenderer ( BaseRenderer ): \"\"\"Custom renderer for specialized visualization.\"\"\" def render ( self , data : VisualizationData ) -> str : \"\"\"Render custom visualization.\"\"\" lines = [] lines . append ( \"CUSTOM VISUALIZATION\" ) lines . append ( \"=\" * self . width ) # Custom rendering logic for node in data . nodes . values (): lines . append ( f \"Node: { node . name } ( { node . state . value } )\" ) return \" \\n \" . join ( lines )","title":"Custom Renderers"},{"location":"VISUALIZATION/#custom-exporters","text":"Create custom exporters for specialized output formats: from utilityfog_frontend.cli_viz.exporters import BaseExporter class CustomExporter ( BaseExporter ): \"\"\"Custom exporter for specialized format.\"\"\" def export ( self , data : VisualizationData , output_path : str ) -> bool : \"\"\"Export to custom format.\"\"\" try : # Custom export logic with open ( output_path , 'w' ) as f : f . write ( \"Custom format data \\n \" ) for node in data . nodes . values (): f . write ( f \" { node . id } , { node . name } , { node . state . value } \\n \" ) return True except Exception as e : print ( f \"Export error: { e } \" ) return False","title":"Custom Exporters"},{"location":"VISUALIZATION/#programmatic-usage","text":"Use the visualization system programmatically: import asyncio from utilityfog_frontend.cli_viz import VisualizationCLI async def automated_visualization (): \"\"\"Automated visualization workflow.\"\"\" cli = VisualizationCLI () # Generate demo data demo_args = type ( 'Args' , (), { 'nodes' : 15 , 'messages' : 30 , 'transitions' : 20 , 'output' : 'auto_demo.json' })() cli . cmd_demo ( demo_args ) # Export HTML report export_args = type ( 'Args' , (), { 'input' : 'auto_demo.json' , 'output' : 'auto_report.html' , 'format' : 'html' , 'width' : 800 , 'height' : 600 })() cli . cmd_export ( export_args ) print ( \"Automated visualization complete\" ) # Run automated workflow asyncio . run ( automated_visualization ())","title":"Programmatic Usage"},{"location":"VISUALIZATION/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"VISUALIZATION/#memory-usage","text":"Node data is kept in memory for fast access Message and transition history is limited (configurable) Large datasets may require data streaming or pagination","title":"Memory Usage"},{"location":"VISUALIZATION/#rendering-performance","text":"ASCII rendering is optimized for terminal display SVG generation scales with node count HTML export includes embedded CSS/JS for self-contained reports","title":"Rendering Performance"},{"location":"VISUALIZATION/#interactive-mode_1","text":"Refresh rate affects CPU usage Terminal I/O may have platform-specific limitations Large datasets may cause display lag","title":"Interactive Mode"},{"location":"VISUALIZATION/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"VISUALIZATION/#common-issues","text":"Import Errors : Ensure all dependencies are installed File Not Found : Check input file paths and permissions Display Issues : Verify terminal size and color support Interactive Mode : Requires Unix-like system with termios","title":"Common Issues"},{"location":"VISUALIZATION/#debug-mode","text":"Enable debug output for troubleshooting: import logging logging . getLogger ( 'utilityfog_frontend.cli_viz' ) . setLevel ( logging . DEBUG )","title":"Debug Mode"},{"location":"VISUALIZATION/#performance-tuning","text":"Reduce time windows for large datasets Use appropriate display dimensions Limit node metadata for better performance","title":"Performance Tuning"},{"location":"VISUALIZATION/#api-reference","text":"","title":"API Reference"},{"location":"VISUALIZATION/#core-classes","text":"","title":"Core Classes"},{"location":"VISUALIZATION/#visualizationdata","text":"Container for all visualization data. Methods: - add_node(node) : Add a tree node - add_message(message) : Add a message flow - add_transition(transition) : Add a state transition - get_active_nodes() : Get nodes in active state - get_recent_messages(seconds) : Get recent messages - get_node_hierarchy() : Get hierarchical structure","title":"VisualizationData"},{"location":"VISUALIZATION/#treenode","text":"Represents a node in the fractal tree. Properties: - id : Unique node identifier - name : Display name - state : Current node state - parent_id : Parent node ID - children : List of child node IDs - metadata : Additional node data","title":"TreeNode"},{"location":"VISUALIZATION/#messageflow","text":"Represents a message between nodes. Properties: - source_id : Source node ID - target_id : Target node ID - message_type : Type of message - content : Message content - status : Delivery status","title":"MessageFlow"},{"location":"VISUALIZATION/#statetransition","text":"Represents a state change event. Properties: - node_id : Node that changed state - from_state : Previous state - to_state : New state - trigger : What caused the transition","title":"StateTransition"},{"location":"VISUALIZATION/#renderers","text":"","title":"Renderers"},{"location":"VISUALIZATION/#treerenderer","text":"Renders hierarchical tree structure.","title":"TreeRenderer"},{"location":"VISUALIZATION/#flowrenderer","text":"Renders message flows between nodes.","title":"FlowRenderer"},{"location":"VISUALIZATION/#staterenderer","text":"Renders state transitions over time.","title":"StateRenderer"},{"location":"VISUALIZATION/#interactiverenderer","text":"Provides interactive real-time visualization.","title":"InteractiveRenderer"},{"location":"VISUALIZATION/#exporters","text":"","title":"Exporters"},{"location":"VISUALIZATION/#htmlexporter","text":"Exports interactive HTML reports.","title":"HTMLExporter"},{"location":"VISUALIZATION/#svgexporter","text":"Exports scalable vector graphics.","title":"SVGExporter"},{"location":"VISUALIZATION/#textexporter","text":"Exports plain text reports.","title":"TextExporter"},{"location":"VISUALIZATION/#jsonexporter","text":"Exports structured JSON data.","title":"JSONExporter"},{"location":"VISUALIZATION/#future-enhancements","text":"3D Visualization : WebGL-based 3D tree rendering Real-time Streaming : Live data feed integration Advanced Analytics : Statistical analysis and pattern detection Custom Themes : User-defined color schemes and layouts Plugin System : Extensible renderer and exporter plugins Performance Optimization : Lazy loading and data virtualization Mobile Support : Responsive design for mobile devices Collaboration Features : Shared visualization sessions","title":"Future Enhancements"},{"location":"agent-safety-policy/","text":"Agent Safety Policy (seed) \u00b6 This PR adds the Agent Safety Suite: OPA policy, YAML caps, kill-switch, and CI.","title":"Agent Safety Policy (seed)"},{"location":"agent-safety-policy/#agent-safety-policy-seed","text":"This PR adds the Agent Safety Suite: OPA policy, YAML caps, kill-switch, and CI.","title":"Agent Safety Policy (seed)"}]}